#!/usr/bin/env python3

import argparse
import pathlib

from wintertools import buildgen
from wintertools.third_party import ninja_syntax

# Check the python version before doing anything else.
buildgen.check_python_version()

# Make sure we're in the right directory.
buildgen.ensure_directory()

# Gemini-specific sources, includes, and defines.

PROGRAM = "sim"
buildgen.GCC = "clang"

SRCS = [
    # From simulator
    "./*.c",
    "./*.cpp",
    "./stubs/*.c",
    # From firmware
    "../src/currents/*.c",
    "../src/flow/*.c",
    "../third_party/libwinter/wntr_deque.c",
]

INCLUDES = [
    "../src/lib",
    "../third_party/libwinter",
]

DEFINES = buildgen.Desktop.defines()

DEFINES.update(dict())


# Toolchain configuration. Wintertools does most of the work here.


COMMON_FLAGS = buildgen.Desktop.common_flags() + [
    "-Wno-unused-parameter",
    "-Wno-unused-variable",
]

COMPILE_FLAGS = buildgen.Desktop.cc_flags()

DEBUG_COMPILER_FLAGS = [
    "-ggdb3 -Og",
]

LINK_FLAGS = buildgen.Desktop().ld_flags(use_cxx=True)

LINK_LIBRARIES = [
    "-lm",
    "-lsdl2",
    "-lcairo",
    "-lrtmidi",
]

DEBUG_DEFINES = dict(DEBUG=1)


# Buildfile generation


def generate_build(run_generators, enable_tidy, enable_format):
    srcs = buildgen.expand_srcs(SRCS)
    INCLUDES.extend(buildgen.includes_from_srcs(srcs))

    compiler_flags = COMMON_FLAGS + COMPILE_FLAGS
    linker_flags = COMMON_FLAGS + LINK_FLAGS
    DEFINES.update(DEBUG_DEFINES)
    compiler_flags += DEBUG_COMPILER_FLAGS

    buildfile_path = pathlib.Path("./build.ninja")
    buildfile = buildfile_path.open("w")
    writer = ninja_syntax.Writer(buildfile)

    # Global variables

    writer.comment("This is generated by configure.py- don't edit it directly!")
    writer.newline()

    buildgen.toolchain_variables(
        writer,
        cc_flags=compiler_flags,
        linker_flags=linker_flags,
        includes=INCLUDES,
        defines=DEFINES,
        libraries=LINK_LIBRARIES,
    )

    # Use wintertools' common rules for compiling and such.
    buildgen.common_rules(writer)

    # Builds for compiling, linking, and outputting elf, bin, and uf2, and
    # checking size.
    objects = buildgen.compile_build(writer, srcs)
    buildgen.link_build(writer, PROGRAM, objects)

    # Builds for generated files

    # Build info is always generated, even if generators are disabled.
    buildgen.build_info_build(writer, "debug")

    if run_generators:
        buildgen.py_generated_file_build(writer, "../experimental/generator.py", "../src/flow/generated_flow.c")

    # Formatting and linting
    if enable_format:
        format_files = list(pathlib.Path(".").glob("src/**/*.[c,h]"))
        buildgen.clang_format_build(writer, format_files)

    if enable_tidy:
        tidy_files = list(pathlib.Path(".").glob("src/**/*.c"))
        buildgen.clang_tidy_build(writer, tidy_files)

    # Special reconfigure build
    buildgen.reconfigure_build(writer)

    # All done. :)
    writer.close()


def main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument("--skip-checks", action="store_true", default=False)
    parser.add_argument("--no-generators", action="store_true", default=False)
    parser.add_argument("--enable-tidy", action="store_true", default=False)
    parser.add_argument("--no-format", action="store_true", default=False)

    args = parser.parse_args()

    if not args.skip_checks:
        buildgen.check_gcc_version()

    generate_build(not args.no_generators, args.enable_tidy, not args.no_format)

    print("Created build.ninja")


if __name__ == "__main__":
    main()
